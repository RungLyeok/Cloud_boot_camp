<h1>오류 검출</h1>

<h3>📌INDEX</h3>

- [오류](#오류)
-  [오류 복구](#오류-복구)
-  [오류 검출](#오류-검출)
    -  [패리티 비트 검사](#패리티-비트-검사)
    -  [순환중복검사(CRC)](#순환-중복-검사)
<br><br>

<h2>오류</h2>

- 수신 측으로 전송한 데이터는 송신 측의 데이터와 동일해야 하지만, 다양한 원인 때문에 데이터 오류가 발생할 수 있다. 
- 따라서 신뢰할 수 있는 네트워크 통신을 하려면 오류를 검출·수정해야한다.
<br>

<img src="https://user-images.githubusercontent.com/64996121/153367306-faea121c-1479-4e81-9d7c-be2fe0b2a6f8.PNG" width="500" height="300"/>


- **단일 - 비트 오류(Single-bit Error)**
  - 데이터 단위 중 하나의 비트만 변경하는 오류를 말한다. (하나만 오류)
- **다중 - 비트 오류(Multible-bit Error)**
  - 데이터 단위 중 2개 이상의 비연속적인 비트를 변경하는 오류를 말한다.
- **집단 오류(Burst Error)**
  - 데이터 단위 중 2개 또는 그 이상의 연속적인 비트를 변경하는 오류를 말한다. 

<br><br>

<h2>오류 복구</h2>

- 순방향 오류 복구 
  - 오류 복구 코드를 이용해 수신 호스트 스스로 오류를 복구
  - 헤더코드에 오류코드를 넣어 검사
- 역방향 오류 복구
  - 오류 검출 코드를 이용해 수신 호스트가 송신 호스트에게 오류를 통지 
  - 먼저 수신측에서 검사 -> 오류 있으면 재요청

<br><br>

<h2>오류 검출</h2>

- <h4>패리티 비트 검사</h4>

  - 패리티 비트 검사(Parity Bit Check)는 전송하는 데이터마다 패리티 비트를 하나씩 추가하여 홀수 또는 짝수 검사 방법으로 오류를 검출
  - 추가로 전송되는 1비트를 '패리티 비트'라고 한다.
  - 패리티 비트의 값은 데이터 코드 내에 있는 1의 수를 계산함으로써 결정된다.
  - **홀수 패리티 방식(Odd Parity)**
    - 전체 비트에서 1의 개수가 홀수가 되도록 패리티 비트를 정하는 것
    - 데이터 비트에서 1의 개수가 짝수면 패리티 비트를 1로 정하여 전송되는 전체 데이터에 있는 1의 개수를 홀수가 된다.
  - **짝수 패리티 방식(Even Parity)**
    - 전체 비트에서 1의 개수가 짝수가 되도록 패리티 비트를 정하는 것
    - 데이터 비트에서 1의 개수가 홀수면 패리티 비트를 1로 정하여 전송되는 전체 데이터에 있는 1의 개수는 짝수가 된다. 
  - **블록 합 검사(Block Sum Check)**
    - 오류 검출 능력을 향상시키기 위해 문자 블록에 수평 패리티와 수직 패리티를 2차원적으로 검사하는 방법
    - 행 단위 패리티에 열 단위의 오류 검사를 수행할 수 있는 열 패리티 문자를 추가하여 이중으로 오류 검출 작업을 수행
    - 추가된 열 패리티 문자를 '블록 검사 문자(BCC, Block Check Character)'라고 한다.
    - 블록 합 검사를 이용하면 한 데이터에서 짝수개의 오류가 발생하더라도 오류를 검출 가능

<img src="https://user-images.githubusercontent.com/64996121/153367448-872fef5d-9956-4f30-ae02-74feadc8681e.PNG" style="zoom:85%;" />

<br>

- <h4>순환 중복 검사</h4>

  - 순환 중복 검사(**CRC**, Cyclic Redundancy Check)는 정확하게 오류를 검출하기 위해 **다항식 코드를 사용**하는 방법이다. -> 오류 검출 100% 가능

  - 오류가 없을 때는 계속 발생하지 않다가 오류가 발생하면 그 주위에 집중적으로 오류를 발생시키는 **집단 오류를 검출하는 능력이 탁월**하고, 구현이 단순하다.

  - CRC 발생코드(다항식 or 2진 코드)를 데이터와 **XOR 연산**한 나머지를 **데이터에 덧붙여 전송**, 수신측에서 비교하는 방법

  - **다항식(Polynomial)**

    - CRC 발생기는 0과 1의 스트링 보다는 대수 다항식으로 표현하며, 하나의 다항식은 하나의 제수(Divisor)를 표현한다.

  - **다항 코드**

    - 생성 다항식

      - > ex1) 생성 다항식 = x^5 + x^2 + 1
        >
        > = x^5 * 1 + x^4 * 0 + x^3 * 0 +  x^2 * 1 + x^1 * 0 + x^0 * 1 -> 차수의 계수는 100101
        >
        > 따라서, **다항코드 = 100101**
        >
        > ex2) 그림
        >
        > ![다항식 예씨](https://user-images.githubusercontent.com/64996121/153407656-460a5957-ccc4-4889-9639-e044bc82377b.PNG)



      - 전송 데이터: m 비트 크기의 M(x)

      - 생성 다항식: n+1비트 크기의 G(x)

      - **체크섬**

        - 전송 데이터와 생성 다항식을 이용하여 계산
        - n 비트 크기
        - **나누는 과정 XOR 연산 : 두 수가 같으면 0, 다르면 1**
        - 계산 예시

        > 생성 다항식 G(x) = x5 + x2 + 1
        >
        > 전송 데이터: 101101001
        >
        > 체크섬: 00010
        >
        > <img src="https://user-images.githubusercontent.com/64996121/153407452-e8998905-d953-4db6-998d-63ba9aa3bf7e.PNG" style="zoom:70%;" />
        >
        > 

      - 송신 호스트: **"전송 데이터 + 체크섬"을 수신 호스트에게 전송**

      - 수신 호스트: "전송 데이터 + 체크섬"을 **생성 다항식으로 나누어 결과를 확인**

        - **나머지가 0이면 전송 오류가 없는 경우**
        - **나머지가 0이 아니면 전송 오류가 있는 경우**

      1️⃣ 송신 측

      a. 데이터 전송

      b. 오류 검출코드 계산

      c. CRC 추가

      2️⃣ 수신 측

      a. 데이터 수신

      b. 오류 검출 코드 계산

      c. 수신된 CRC와 계산된 CRC 비교 검사

       d. 동일하지 않으면 오류 검출 신호 발생 
